# Skill: ai.chatkit.backend

OpenAI ChatKit Python Backend - production patterns for building AI chatbots.

## Overview

Build production-ready AI chatbots using OpenAI's ChatKit framework with proper architecture, authentication, and best practices.

```
Browser → ChatKit widget → Python Backend → Agents SDK → OpenAI/Gemini
```

## Quick Start Pattern

### Option 1: OpenAI-Hosted Backend (Fastest Setup)

Use this approach when OpenAI manages infrastructure:

**Step 1: Create Agent Workflow** in Agent Builder (platform.openai.com)
- Get workflow ID from Agent Builder
- Configure agents, tools, and logic visually

**Step 2: Set Up Backend Endpoint** for session creation:

```python
from fastapi import FastAPI
from openai import OpenAI
import os

app = FastAPI()
openai = OpenAI(api_key=os.environ["OPENAI_API_KEY"])

@app.post("/api/chatkit/session")
def create_chatkit_session():
    session = openai.chatkit.sessions.create({
        "workflow": {"id": "wf_YOUR_WORKFLOW_ID"},
        "user": "unique_user_id"  # Use actual user identification
    })
    return {"client_secret": session.client_secret}
```

**Step 3: Frontend Integration**:

```html
<script src="https://cdn.platform.openai.com/deployments/chatkit/chatkit.js" async></script>
<div id="my-chat"></div>

<script>
const chatkit = document.getElementById('my-chat');
chatkit.setOptions({
  api: {
    async getClientSecret(currentClientSecret) {
      if (!currentClientSecret) {
        const res = await fetch('/api/chatkit/session', { method: 'POST' });
        const {client_secret} = await res.json();
        return client_secret;
      }
      // Refresh logic
      const res = await fetch('/api/chatkit/refresh', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ currentClientSecret })
      });
      const {client_secret} = await res.json();
      return client_secret;
    }
  }
});
</script>
```

### Option 2: Self-Hosted Custom Backend (This Project)

Use when requiring full control over infrastructure, custom authentication, or data residency.

## Architecture Patterns

**Pattern 1: Simple Embedded Chat**
- Single agent workflow
- OpenAI-hosted backend
- Minimal customization
- Use for: Basic support bots, simple Q&A

**Pattern 2: Multi-Agent Workflow**
- Complex routing between specialized agents
- Custom tool integrations
- Use for: Advanced support, research agents, task automation

**Pattern 3: Full Custom Backend (This Project)**
- Self-hosted ChatKitServer
- Custom database and authentication
- Widget-rich experiences
- Use for: Enterprise applications, data-sensitive deployments

---

## THIS PROJECT: Custom Backend Implementation

### Key Concept: Widgets are Streamed from Tools

**CRITICAL**: Widgets are NOT generated by agent text responses. They are streamed DIRECTLY from MCP tools using `AgentContext`.

```python
from agents import function_tool, RunContextWrapper
from chatkit.agents import AgentContext
from chatkit.widgets import ListView, ListViewItem, Text

@function_tool
async def list_tasks(
    ctx: RunContextWrapper[AgentContext],
    user_id: str,
    status: str = "all"
) -> None:
    """List user's tasks and display in a widget."""
    # Fetch data
    tasks = await fetch_tasks_from_db(user_id, status)

    # Create widget
    widget = create_task_list_widget(tasks)

    # Stream widget to ChatKit UI
    await ctx.context.stream_widget(widget)
    # Tool returns None - widget is already streamed
```

### Agent Instructions Pattern

Agent instructions should NOT format widget data:

```python
AGENT_INSTRUCTIONS = """
You are a helpful task management assistant.

IMPORTANT: When list_tasks or get_tasks is called, DO NOT format the data yourself.
Simply say "Here are your tasks" or a similar brief acknowledgment.
The data will be displayed automatically in a widget.
"""
```

## Project Structure

```
backend/
├── app/
│   ├── chatkit/
│   │   ├── __init__.py       # Module exports
│   │   ├── server.py         # TodoChatKitServer implementation
│   │   ├── widgets.py        # Widget creation helpers
│   │   └── types.py          # Type definitions
│   ├── agents/
│   │   ├── sdk_tools.py      # @function_tool implementations with widgets
│   │   └── core/
│   │       └── todo_agent.py # Agent definition
│   └── api/
│       └── chat.py           # FastAPI endpoints (/chat/chatkit)
```

## ChatKit Server Implementation

```python
# backend/app/chatkit/server.py
from typing import AsyncIterator, Any
from agents import Agent, Runner
from chatkit import ChatKitServer, ThreadMetadata, ThreadStreamEvent
from chatkit.agents import simple_to_agent_input, stream_agent_response, AgentContext

class TodoChatKitServer(ChatKitServer):
    def __init__(self, agent: Agent, store: Any):
        self.agent = agent
        self.store = store

    async def respond(
        self,
        thread: ThreadMetadata,
        input: UserMessageItem | None,
        context: Any,
    ) -> AsyncIterator[ThreadStreamEvent]:
        """Process user messages and stream responses."""

        # Create agent context for widget streaming
        agent_context = AgentContext(
            thread=thread,
            store=self.store,
            request_context=context,
        )

        # Convert ChatKit input to Agent SDK format
        agent_input = await simple_to_agent_input(input) if input else []

        # Run agent with streaming
        result = Runner.run_streamed(
            self.agent,
            agent_input,
            context=agent_context,
        )

        # Stream agent response (text only - widgets streamed by tools)
        async for event in stream_agent_response(agent_context, result):
            yield event
```

## Widget Creation with chatkit.widgets

```python
# backend/app/chatkit/widgets.py
from chatkit.widgets import ListView, ListViewItem, Text, Row, Col, Badge

def create_task_list_widget(tasks: list[dict]) -> ListView:
    """Create a ListView widget for tasks."""

    if not tasks:
        return ListView(
            children=[
                ListViewItem(
                    children=[
                        Text(
                            value="No tasks found",
                            color="secondary",
                            italic=True
                        )
                    ]
                )
            ],
            status={"text": "Tasks (0)", "icon": {"name": "list"}}
        )

    list_items = []
    for task in tasks:
        icon = "check" if task.get("completed") else "circle"

        list_items.append(
            ListViewItem(
                children=[
                    Row(
                        children=[
                            Text(value=icon, size="lg"),
                            Col(
                                children=[
                                    Text(
                                        value=task["title"],
                                        weight="semibold",
                                        color="primary",
                                        lineThrough=task.get("completed", False)
                                    ),
                                    Text(
                                        value=task.get("description", ""),
                                        size="sm",
                                        color="secondary"
                                    ) if task.get("description") else None
                                ],
                                gap=1
                            ),
                            Badge(
                                label=f"#{task['id']}",
                                color="secondary",
                                size="sm"
                            )
                        ],
                        gap=3,
                        align="start"
                    )
                ],
                gap=2
            )
        )

    return ListView(
        children=list_items,
        status={"text": f"Tasks ({len(tasks)})", "icon": {"name": "check-square"}},
        limit="auto"
    )
```

## Agent with Function Tools

```python
# backend/app/agents/todo_agent.py
from agents import Agent, function_tool, RunContextWrapper
from chatkit.agents import AgentContext
from app.chatkit.widgets import create_task_list_widget
from app.services.task_service import TaskService

@function_tool
async def list_tasks(
    ctx: RunContextWrapper[AgentContext],
    status: str = "all"
) -> None:
    """List user's tasks and display in a widget.

    Args:
        status: Filter by status - 'all', 'pending', or 'completed'.
    """
    user_id = ctx.context.request_context.get("user_id")
    tasks = await TaskService.get_tasks(user_id, status)

    widget = create_task_list_widget(tasks)
    await ctx.context.stream_widget(widget)


@function_tool
async def add_task(
    ctx: RunContextWrapper[AgentContext],
    title: str,
    description: str = None
) -> str:
    """Create a new task.

    Args:
        title: The title of the task.
        description: Optional description.
    """
    user_id = ctx.context.request_context.get("user_id")
    task = await TaskService.create_task(user_id, title, description)
    return f"Created task: {task.title} (ID: {task.id})"


@function_tool
async def complete_task(
    ctx: RunContextWrapper[AgentContext],
    task_id: int
) -> str:
    """Mark a task as complete.

    Args:
        task_id: The ID of the task to complete.
    """
    user_id = ctx.context.request_context.get("user_id")
    task = await TaskService.complete_task(user_id, task_id)
    return f"Completed task: {task.title}"


# Create the agent
todo_agent = Agent(
    name="TaskAssistant",
    instructions="""You are a helpful task management assistant.

IMPORTANT: When list_tasks is called, DO NOT format or display the data yourself.
Simply say "Here are your tasks" or a similar brief acknowledgment.
The data will be displayed automatically in a widget.

For other operations (add, complete, delete), provide a helpful confirmation message.
""",
    model="gpt-4o-mini",
    tools=[list_tasks, add_task, complete_task],
)
```

## FastAPI Endpoints

```python
# backend/app/api/chat.py
from fastapi import APIRouter, Depends, Request
from fastapi.responses import StreamingResponse
from app.auth.dependencies import get_current_user
from app.chatkit.server import TodoChatKitServer
from app.agents.todo_agent import todo_agent

router = APIRouter(prefix="/chatkit", tags=["ChatKit"])

# Initialize ChatKit server
chatkit_server = TodoChatKitServer(agent=todo_agent, store=None)

@router.post("/api")
async def chatkit_api(
    request: Request,
    current_user: dict = Depends(get_current_user)
):
    """Main ChatKit API endpoint."""
    body = await request.json()

    # Add user context
    context = {"user_id": current_user["user_id"]}

    async def generate():
        async for event in chatkit_server.process(body, context):
            yield f"data: {event.json()}\n\n"

    return StreamingResponse(
        generate(),
        media_type="text/event-stream"
    )
```

## Session Management

**Critical**: Never expose API keys on frontend. Always create sessions server-side.

Client secret lifecycle:
- Generated server-side per session
- Passed to frontend immediately
- Used by ChatKit client library to authenticate
- Refresh when expired

```python
# Good: Unique, persistent user ID
session = openai.chatkit.sessions.create({
    "workflow": {"id": workflow_id},
    "user": f"user_{user_database_id}"
})

# Bad: Generic or random IDs
"user": "anonymous_user"  # Don't do this
```

## Security Best Practices

**API Key Protection**
- Store in environment variables
- Never commit to version control
- Use separate keys for dev/prod
- Rotate regularly

**User Authentication**
- Verify user identity before session creation
- Implement proper access controls
- Use secure session tokens
- Validate requests server-side

**Data Privacy**
- Follow data residency requirements
- Implement conversation encryption
- Audit tool access
- Comply with privacy regulations

**Rate Limiting**
- Implement request throttling
- Monitor usage patterns
- Set conversation limits
- Prevent abuse

## Environment Variables

```env
# OpenAI
OPENAI_API_KEY=sk-...
OPENAI_DEFAULT_MODEL=gpt-4o-mini
LLM_PROVIDER=openai

# Or Gemini (OpenAI-compatible endpoint)
LLM_PROVIDER=gemini
GEMINI_API_KEY=...
GEMINI_DEFAULT_MODEL=gemini-2.5-flash
```

## Testing and Debugging

**Local Testing**
```bash
# Run FastAPI backend
uvicorn app.main:app --reload

# Test session creation
curl -X POST http://localhost:8000/api/chatkit/session
```

**Console Debugging**
```javascript
// Enable debug mode
chatkit.setOptions({
  debug: true
});

// Monitor events
chatkit.on('message', (msg) => console.log('Message:', msg));
chatkit.on('error', (err) => console.error('Error:', err));
```

### Debugging Common Issues

**Widgets not rendering**
1. Check: Did tool call `await ctx.context.stream_widget(widget)`?
2. Check: Is `ctx: RunContextWrapper[AgentContext]` in tool signature?
3. Check: Is frontend CDN script loaded?

**Agent outputting widget data as text/JSON**
- Fix: Update agent instructions to NOT format widget data
- Pattern: "Simply say 'Here are the results' - data displays automatically"

**Widget shows but is blank**
1. Check widget construction - are all required fields present?
2. Check widget type compatibility
3. Check frontend CDN script for styling

**CORS errors**
- Check FastAPI CORS middleware configuration
- Ensure frontend origin is in allowed_origins

## Troubleshooting Reference

### Connection Issues

**"Failed to connect to ChatKit server"**
1. Verify API Key: `echo $OPENAI_API_KEY`
2. Check Workflow ID exists in Agent Builder
3. Verify domain configuration and CORS settings
4. Enable debug mode in console

**"Client secret expired"**
- Implement proper session refresh in `getClientSecret`

### Authentication Issues

**"Unauthorized access"**
```python
@app.post("/api/chatkit/session")
async def create_session(request: Request):
    token = request.headers.get("Authorization")
    if not token:
        raise HTTPException(status_code=401, detail="Unauthorized")

    user = verify_jwt_token(token)
    if not user:
        raise HTTPException(status_code=401, detail="Invalid token")

    session = openai.chatkit.sessions.create({
        "workflow": {"id": WORKFLOW_ID},
        "user": str(user.id)
    })
    return {"client_secret": session.client_secret}
```

### Widget Issues

**Widgets not rendering**
- Validate widget JSON structure
- Ensure all IDs are unique
- Check component types are valid: card, text, button, input, form, list, image, column, row

**Widget actions not working**
```python
class MyChatKitServer(ChatKitServer):
    async def action(self, action_type: str, payload: dict, context: Any):
        if action_type == "my_action":
            result = await process_action(payload)
            yield create_response_widget(result)
        else:
            raise ValueError(f"Unknown action: {action_type}")
```

### Performance Issues

**Slow response times**
- Optimize widget size (avoid 100+ items)
- Stream partial updates for long-running tasks
- Cache common responses with `@lru_cache`

**High memory usage**
- Limit conversation history (last 50 messages)
- Clean up resources in finally blocks

## Deployment Checklist

- [ ] API keys secured in environment
- [ ] Session endpoint implemented with auth
- [ ] Workflow ID configured correctly
- [ ] Error handling implemented
- [ ] Rate limiting configured
- [ ] CORS settings validated
- [ ] HTTPS enabled
- [ ] Domain allowlist configured (if using)
- [ ] Monitoring and logging set up
- [ ] User feedback mechanism added

## File Locations

- ChatKit server: `backend/app/chatkit/server.py`
- SDK tools with widgets: `backend/app/agents/sdk_tools.py`
- Widget helpers: `backend/app/chatkit/widgets.py`
- API endpoints: `backend/app/api/chat.py`

## API Endpoints

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/chat/chatkit` | POST | Main ChatKit API (streaming SSE) |
| `/chat/chatkit/upload` | POST | File uploads (not implemented) |
| `/chat/{user_id}` | POST | Legacy chat endpoint |
| `/chat/{user_id}/history` | GET | Chat history |

## Related Skills

- `ai.chatkit.frontend` - Frontend ChatKit integration
- `auth.backendjwt` - JWT authentication for ChatKit